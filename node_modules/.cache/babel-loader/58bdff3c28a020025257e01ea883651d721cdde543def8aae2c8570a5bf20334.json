{"ast":null,"code":"// src/Analytics.ts\n\nexport class Analytics {\n  // 2% annual risk-free rate\n\n  static validateParams(params) {\n    if (params.alpha < 0 || params.alpha > 1) {\n      throw new Error('Alpha must be between 0 and 1');\n    }\n    if (params.beta < 0 || params.beta > 1) {\n      throw new Error('Beta must be between 0 and 1');\n    }\n    if (params.alpha + params.beta >= 1) {\n      throw new Error('Alpha + Beta must be less than 1 for GARCH stability');\n    }\n    if (params.theta < 0 || params.theta > 1) {\n      throw new Error('Theta must be between 0 and 1');\n    }\n    if (params.switchProb < 0 || params.switchProb > 1) {\n      throw new Error('Switch probability must be between 0 and 1');\n    }\n    if (params.numPaths < 100 || params.numPaths > 10000) {\n      throw new Error('Number of paths must be between 100 and 10000');\n    }\n    if (params.numSteps < 10 || params.numSteps > 1000) {\n      throw new Error('Number of steps must be between 10 and 1000');\n    }\n  }\n  static calculateReturns(prices) {\n    if (prices.length < 2) {\n      throw new Error('Need at least 2 price points to calculate returns');\n    }\n    const returns = [];\n    for (let i = 1; i < prices.length; i++) {\n      if (prices[i - 1].close <= 0) {\n        throw new Error('Invalid price data: non-positive close price');\n      }\n      const ret = Math.log(prices[i].close / prices[i - 1].close);\n      returns.push(ret);\n    }\n    return returns;\n  }\n  static calculateGARCHVolatility(returns, alpha, beta) {\n    if (returns.length === 0) {\n      throw new Error('No returns data provided');\n    }\n\n    // Validate GARCH parameters\n    if (alpha < 0 || beta < 0 || alpha + beta >= 1) {\n      throw new Error('Invalid GARCH parameters: alpha + beta must be < 1');\n    }\n    const n = returns.length;\n    const volatilities = [];\n\n    // Handle edge case with minimal data\n    if (n === 1) {\n      const volatility = Math.sqrt(Math.max(Math.pow(returns[0], 2), this.MIN_VARIANCE));\n      return [volatility];\n    }\n\n    // Calculate sample variance for omega with robust estimation\n    const meanReturn = returns.reduce((sum, r) => sum + r, 0) / n;\n    const sampleVar = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (n - 1);\n\n    // Ensure sample variance is positive and reasonable\n    const adjustedSampleVar = Math.max(sampleVar, this.MIN_VARIANCE);\n    const omega = adjustedSampleVar * (1 - alpha - beta);\n\n    // Initialize first volatility\n    volatilities[0] = Math.sqrt(adjustedSampleVar);\n\n    // GARCH(1,1) recursion: σ²_t = ω + α·r²_{t-1} + β·σ²_{t-1}\n    for (let t = 1; t < n; t++) {\n      const variance = omega + alpha * Math.pow(returns[t - 1], 2) + beta * Math.pow(volatilities[t - 1], 2);\n\n      // Apply variance bounds for numerical stability\n      const boundedVariance = Math.max(Math.min(variance, this.MAX_VARIANCE), this.MIN_VARIANCE);\n      volatilities[t] = Math.sqrt(boundedVariance);\n    }\n    return volatilities;\n  }\n  static calculateTrendAndDrift(prices, theta) {\n    if (prices.length < 2) {\n      throw new Error('Need at least 2 price points to calculate trend');\n    }\n    if (theta < 0 || theta > 1) {\n      throw new Error('Theta must be between 0 and 1');\n    }\n    const n = prices.length;\n    const logPrices = prices.map(p => {\n      if (p.close <= 0) {\n        throw new Error('Invalid price data: non-positive close price');\n      }\n      return Math.log(p.close);\n    });\n\n    // OLS regression: y = mx + b\n    const xMean = (n - 1) / 2;\n    const yMean = logPrices.reduce((sum, y) => sum + y, 0) / n;\n    let numerator = 0;\n    let denominator = 0;\n    for (let i = 0; i < n; i++) {\n      const x = i;\n      const y = logPrices[i];\n      numerator += (x - xMean) * (y - yMean);\n      denominator += Math.pow(x - xMean, 2);\n    }\n\n    // Handle edge case where denominator is zero\n    if (Math.abs(denominator) < 1e-10) {\n      return {\n        trend: prices[n - 1].close,\n        drift: 0\n      };\n    }\n    const slope = numerator / denominator;\n    const trend = Math.exp(slope * n); // Projected price based on trend\n    const currentPrice = prices[n - 1].close;\n    const drift = theta * (trend - currentPrice) / currentPrice;\n    return {\n      trend,\n      drift\n    };\n  }\n  static generateMarkovRegime(returns, switchProb) {\n    if (returns.length === 0) {\n      throw new Error('No returns data provided');\n    }\n    if (switchProb < 0 || switchProb > 1) {\n      throw new Error('Switch probability must be between 0 and 1');\n    }\n    const n = returns.length;\n    const regimes = [];\n\n    // Start in regime based on last return\n    let currentRegime = returns[returns.length - 1] >= 0 ? 1 : -1;\n    for (let t = 0; t < n; t++) {\n      regimes[t] = currentRegime;\n\n      // Switch regime with probability switchProb\n      if (Math.random() < switchProb) {\n        currentRegime = -currentRegime;\n      }\n    }\n    return regimes;\n  }\n  static runMonteCarloSimulation(initialPrice, params, initialVolatility, drift) {\n    // Validate inputs\n    this.validateParams(params);\n    if (initialPrice <= 0) {\n      throw new Error('Initial price must be positive');\n    }\n    if (initialVolatility <= 0) {\n      throw new Error('Initial volatility must be positive');\n    }\n    const {\n      numPaths,\n      numSteps,\n      alpha,\n      beta\n    } = params;\n    const paths = [];\n    const dt = 1 / 252; // Daily time step\n\n    // Calculate omega for GARCH\n    const omega = initialVolatility * initialVolatility * (1 - alpha - beta);\n    for (let path = 0; path < numPaths; path++) {\n      const pathPrices = [initialPrice];\n      let currentPrice = initialPrice;\n      let currentVolatility = initialVolatility;\n      for (let step = 0; step < numSteps; step++) {\n        // Generate random normal variable\n        const z = this.randomNormal();\n\n        // Calculate return: ret = drift·dt - 0.5·σ²·dt + σ·√dt·Z\n        const ret = drift * dt - 0.5 * currentVolatility * currentVolatility * dt + currentVolatility * Math.sqrt(dt) * z;\n\n        // Update price with bounds checking\n        currentPrice = currentPrice * Math.exp(ret);\n        if (currentPrice < this.MIN_PRICE) {\n          currentPrice = this.MIN_PRICE; // Prevent negative prices\n        }\n        pathPrices.push(currentPrice);\n\n        // Update volatility using GARCH with bounds\n        const variance = omega + alpha * Math.pow(ret, 2) + beta * Math.pow(currentVolatility, 2);\n        const boundedVariance = Math.max(Math.min(variance, this.MAX_VARIANCE), this.MIN_VARIANCE);\n        currentVolatility = Math.sqrt(boundedVariance);\n      }\n      paths.push(pathPrices);\n    }\n    return this.calculateStatistics(paths, initialPrice);\n  }\n\n  // Advanced Analytics Methods\n\n  static runStressTest(initialPrice, params, initialVolatility, drift, scenarios) {\n    const results = [];\n    for (const scenario of scenarios) {\n      // Apply stress test parameters\n      const stressedParams = {\n        ...params\n      };\n      const stressedVolatility = initialVolatility * scenario.volatilityShock;\n      const stressedDrift = drift + scenario.driftShock;\n\n      // Run simulation with stressed parameters\n      const result = this.runMonteCarloSimulation(initialPrice, stressedParams, stressedVolatility, stressedDrift);\n\n      // Calculate additional stress metrics\n      const finalPrices = result.paths.map(path => path[path.length - 1]);\n      const probabilityOfLoss = finalPrices.filter(price => price < initialPrice).length / finalPrices.length;\n      const maxDrawdown = this.calculateMaxDrawdown(result.paths, initialPrice);\n      results.push({\n        scenario,\n        var95: result.var95,\n        var99: result.var99,\n        expectedShortfall95: result.expectedShortfall95,\n        expectedShortfall99: result.expectedShortfall99,\n        probabilityOfLoss,\n        maxDrawdown\n      });\n    }\n    return results;\n  }\n  static calculatePerformanceMetrics(prices, benchmarkReturns) {\n    const returns = this.calculateReturns(prices);\n    const meanReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;\n    const volatility = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (returns.length - 1));\n\n    // Annualize returns and volatility\n    const annualizedReturn = meanReturn * 252;\n    const annualizedVolatility = volatility * Math.sqrt(252);\n\n    // Sharpe Ratio\n    const sharpeRatio = (annualizedReturn - this.RISK_FREE_RATE) / annualizedVolatility;\n\n    // Sortino Ratio (using downside deviation)\n    const downsideReturns = returns.filter(r => r < meanReturn);\n    const downsideDeviation = Math.sqrt(downsideReturns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / downsideReturns.length);\n    const sortinoRatio = (annualizedReturn - this.RISK_FREE_RATE) / (downsideDeviation * Math.sqrt(252));\n\n    // Maximum Drawdown\n    const maxDrawdown = this.calculateMaxDrawdownFromPrices(prices);\n\n    // Calmar Ratio\n    const calmarRatio = annualizedReturn / Math.abs(maxDrawdown);\n\n    // Beta and Alpha (if benchmark provided)\n    let beta = 1;\n    let alpha = 0;\n    let informationRatio = 0;\n    let treynorRatio = 0;\n    if (benchmarkReturns && benchmarkReturns.length === returns.length) {\n      const benchmarkMean = benchmarkReturns.reduce((sum, r) => sum + r, 0) / benchmarkReturns.length;\n      const benchmarkVar = benchmarkReturns.reduce((sum, r) => sum + Math.pow(r - benchmarkMean, 2), 0) / (benchmarkReturns.length - 1);\n\n      // Calculate covariance\n      let covariance = 0;\n      for (let i = 0; i < returns.length; i++) {\n        covariance += (returns[i] - meanReturn) * (benchmarkReturns[i] - benchmarkMean);\n      }\n      covariance /= returns.length - 1;\n      beta = covariance / benchmarkVar;\n      alpha = annualizedReturn - (this.RISK_FREE_RATE + beta * (benchmarkMean * 252 - this.RISK_FREE_RATE));\n\n      // Information Ratio\n      const trackingError = Math.sqrt(returns.reduce((sum, r, i) => sum + Math.pow(r - benchmarkReturns[i], 2), 0) / returns.length);\n      informationRatio = (annualizedReturn - benchmarkMean * 252) / (trackingError * Math.sqrt(252));\n\n      // Treynor Ratio\n      treynorRatio = (annualizedReturn - this.RISK_FREE_RATE) / beta;\n    }\n    return {\n      sharpeRatio,\n      sortinoRatio,\n      maxDrawdown,\n      calmarRatio,\n      informationRatio,\n      beta,\n      alpha,\n      treynorRatio\n    };\n  }\n  static analyzeRegime(returns, regimes) {\n    if (returns.length !== regimes.length) {\n      throw new Error('Returns and regimes arrays must have the same length');\n    }\n\n    // Calculate regime probabilities\n    const bullCount = regimes.filter(r => r > 0).length;\n    const bearCount = regimes.filter(r => r < 0).length;\n    const totalCount = regimes.length;\n    const bullMarketProbability = bullCount / totalCount;\n    const bearMarketProbability = bearCount / totalCount;\n\n    // Calculate regime durations\n    let currentRegime = regimes[0];\n    let currentDuration = 1;\n    const bullDurations = [];\n    const bearDurations = [];\n    for (let i = 1; i < regimes.length; i++) {\n      if (regimes[i] === currentRegime) {\n        currentDuration++;\n      } else {\n        if (currentRegime > 0) {\n          bullDurations.push(currentDuration);\n        } else {\n          bearDurations.push(currentDuration);\n        }\n        currentRegime = regimes[i];\n        currentDuration = 1;\n      }\n    }\n\n    // Add final regime\n    if (currentRegime > 0) {\n      bullDurations.push(currentDuration);\n    } else {\n      bearDurations.push(currentDuration);\n    }\n\n    // Calculate regime statistics\n    const regimeDuration = {\n      bull: bullDurations.length > 0 ? bullDurations.reduce((sum, d) => sum + d, 0) / bullDurations.length : 0,\n      bear: bearDurations.length > 0 ? bearDurations.reduce((sum, d) => sum + d, 0) / bearDurations.length : 0\n    };\n\n    // Calculate regime-specific returns and volatility\n    const bullReturns = returns.filter((_, i) => regimes[i] > 0);\n    const bearReturns = returns.filter((_, i) => regimes[i] < 0);\n    const regimeReturns = {\n      bull: bullReturns.length > 0 ? bullReturns.reduce((sum, r) => sum + r, 0) / bullReturns.length : 0,\n      bear: bearReturns.length > 0 ? bearReturns.reduce((sum, r) => sum + r, 0) / bearReturns.length : 0\n    };\n    const bullMean = bullReturns.length > 0 ? bullReturns.reduce((sum, r) => sum + r, 0) / bullReturns.length : 0;\n    const bearMean = bearReturns.length > 0 ? bearReturns.reduce((sum, r) => sum + r, 0) / bearReturns.length : 0;\n    const regimeVolatility = {\n      bull: bullReturns.length > 0 ? Math.sqrt(bullReturns.reduce((sum, r) => sum + Math.pow(r - bullMean, 2), 0) / (bullReturns.length - 1)) : 0,\n      bear: bearReturns.length > 0 ? Math.sqrt(bearReturns.reduce((sum, r) => sum + Math.pow(r - bearMean, 2), 0) / (bearReturns.length - 1)) : 0\n    };\n    return {\n      bullMarketProbability,\n      bearMarketProbability,\n      regimeDuration,\n      regimeVolatility,\n      regimeReturns\n    };\n  }\n\n  // Helper methods\n\n  static calculateMaxDrawdown(paths, initialPrice) {\n    let maxDrawdown = 0;\n    for (const path of paths) {\n      let peak = initialPrice;\n      let drawdown = 0;\n      for (const price of path) {\n        if (price > peak) {\n          peak = price;\n        }\n        const currentDrawdown = (peak - price) / peak;\n        if (currentDrawdown > drawdown) {\n          drawdown = currentDrawdown;\n        }\n      }\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n    return maxDrawdown;\n  }\n  static calculateMaxDrawdownFromPrices(prices) {\n    let peak = prices[0].close;\n    let maxDrawdown = 0;\n    for (const price of prices) {\n      if (price.close > peak) {\n        peak = price.close;\n      }\n      const drawdown = (peak - price.close) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n    return maxDrawdown;\n  }\n  static randomNormal() {\n    // Box-Muller transform for normal random variables\n    const u = Math.random();\n    const v = Math.random();\n    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);\n  }\n  static calculateStatistics(paths, initialPrice) {\n    const numPaths = paths.length;\n    const finalPrices = paths.map(path => path[path.length - 1]);\n\n    // Calculate probabilities\n    const upside20Count = finalPrices.filter(price => price >= initialPrice * 1.2).length;\n    const downside10Count = finalPrices.filter(price => price <= initialPrice * 0.9).length;\n    const probabilities = {\n      upside20: upside20Count / numPaths,\n      downside10: downside10Count / numPaths\n    };\n\n    // Calculate histogram\n    const sortedPrices = [...finalPrices].sort((a, b) => a - b);\n    const minPrice = sortedPrices[0];\n    const maxPrice = sortedPrices[sortedPrices.length - 1];\n    const numBins = 50;\n    const binSize = (maxPrice - minPrice) / numBins;\n    const histogram = Array(numBins).fill(0).map((_, i) => ({\n      bin: minPrice + i * binSize,\n      count: 0\n    }));\n    finalPrices.forEach(price => {\n      const binIndex = Math.min(Math.floor((price - minPrice) / binSize), numBins - 1);\n      histogram[binIndex].count++;\n    });\n\n    // Calculate percentiles\n    const percentiles = {};\n    [5, 10, 25, 50, 75, 90, 95].forEach(p => {\n      const index = Math.floor(p / 100 * (numPaths - 1));\n      percentiles[`p${p}`] = sortedPrices[index];\n    });\n\n    // Calculate VaR and Expected Shortfall\n    const var95Index = Math.floor(0.05 * numPaths);\n    const var99Index = Math.floor(0.01 * numPaths);\n    const var95 = initialPrice - sortedPrices[var95Index];\n    const var99 = initialPrice - sortedPrices[var99Index];\n    const expectedShortfall95 = initialPrice - sortedPrices.slice(0, var95Index + 1).reduce((sum, price) => sum + price, 0) / (var95Index + 1);\n    const expectedShortfall99 = initialPrice - sortedPrices.slice(0, var99Index + 1).reduce((sum, price) => sum + price, 0) / (var99Index + 1);\n    return {\n      paths,\n      probabilities,\n      histogram,\n      percentiles,\n      var95,\n      var99,\n      expectedShortfall95,\n      expectedShortfall99,\n      currentVolatility: 0,\n      // Will be set by caller\n      trend: 0,\n      // Will be set by caller\n      drift: 0 // Will be set by caller\n    };\n  }\n\n  // Comprehensive test pipeline for validation\n  static testPipeline() {\n    const errors = [];\n    try {\n      // Generate synthetic data\n      const prices = this.generateSyntheticWalk(100, 0.001, 0.01);\n\n      // Test all components\n      const returns = this.calculateReturns(prices);\n      const volatilities = this.calculateGARCHVolatility(returns, 0.1, 0.8);\n      const {\n        drift\n      } = this.calculateTrendAndDrift(prices, 0.05);\n      const regimes = this.generateMarkovRegime(returns, 0.05);\n      const params = {\n        alpha: 0.1,\n        beta: 0.8,\n        theta: 0.05,\n        switchProb: 0.05,\n        numPaths: 10,\n        numSteps: 10\n      };\n      const result = this.runMonteCarloSimulation(prices[prices.length - 1].close, params, volatilities[volatilities.length - 1], drift);\n\n      // Validation checks\n      if (result.paths.length !== 10 || result.paths[0].length !== 11) {\n        errors.push('Invalid path dimensions');\n      }\n      if (result.probabilities.upside20 < 0 || result.probabilities.upside20 > 1) {\n        errors.push('Invalid upside probability');\n      }\n      if (result.probabilities.downside10 < 0 || result.probabilities.downside10 > 1) {\n        errors.push('Invalid downside probability');\n      }\n      if (result.var95 < 0 || result.var99 < 0) {\n        errors.push('Invalid VaR values');\n      }\n\n      // Check for positive prices\n      const allPrices = result.paths.flat();\n      if (!allPrices.every(price => price > 0)) {\n        errors.push('Non-positive prices detected');\n      }\n\n      // Test advanced features\n      const performanceMetrics = this.calculatePerformanceMetrics(prices);\n      if (isNaN(performanceMetrics.sharpeRatio)) {\n        errors.push('Invalid Sharpe ratio');\n      }\n      const regimeAnalysis = this.analyzeRegime(returns, regimes);\n      if (regimeAnalysis.bullMarketProbability + regimeAnalysis.bearMarketProbability !== 1) {\n        errors.push('Invalid regime probabilities');\n      }\n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : 'Unknown error in test pipeline');\n    }\n    return {\n      success: errors.length === 0,\n      errors\n    };\n  }\n  static generateSyntheticWalk(numPoints, meanReturn, volatility) {\n    const prices = [];\n    let currentPrice = 100; // Start at $100\n\n    for (let i = 0; i < numPoints; i++) {\n      const date = new Date(2024, 0, i + 1); // Start from Jan 1, 2024\n\n      if (i > 0) {\n        // Generate random return using Box-Muller transform\n        const u1 = Math.random();\n        const u2 = Math.random();\n        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        const return_ = meanReturn + volatility * z;\n        currentPrice = currentPrice * Math.exp(return_);\n      }\n      const noise = 0.001; // Small noise for OHLC\n      prices.push({\n        date,\n        open: currentPrice * (1 + (Math.random() - 0.5) * noise),\n        high: currentPrice * (1 + Math.abs(Math.random()) * noise),\n        low: currentPrice * (1 - Math.abs(Math.random()) * noise),\n        close: currentPrice,\n        volume: Math.floor(Math.random() * 1000000)\n      });\n    }\n    return prices;\n  }\n}\n// Validation constants\nAnalytics.MIN_VARIANCE = 1e-8;\nAnalytics.MAX_VARIANCE = 1e4;\nAnalytics.MIN_PRICE = 0.01;\nAnalytics.RISK_FREE_RATE = 0.02;","map":{"version":3,"names":["Analytics","validateParams","params","alpha","Error","beta","theta","switchProb","numPaths","numSteps","calculateReturns","prices","length","returns","i","close","ret","Math","log","push","calculateGARCHVolatility","n","volatilities","volatility","sqrt","max","pow","MIN_VARIANCE","meanReturn","reduce","sum","r","sampleVar","adjustedSampleVar","omega","t","variance","boundedVariance","min","MAX_VARIANCE","calculateTrendAndDrift","logPrices","map","p","xMean","yMean","y","numerator","denominator","x","abs","trend","drift","slope","exp","currentPrice","generateMarkovRegime","regimes","currentRegime","random","runMonteCarloSimulation","initialPrice","initialVolatility","paths","dt","path","pathPrices","currentVolatility","step","z","randomNormal","MIN_PRICE","calculateStatistics","runStressTest","scenarios","results","scenario","stressedParams","stressedVolatility","volatilityShock","stressedDrift","driftShock","result","finalPrices","probabilityOfLoss","filter","price","maxDrawdown","calculateMaxDrawdown","var95","var99","expectedShortfall95","expectedShortfall99","calculatePerformanceMetrics","benchmarkReturns","annualizedReturn","annualizedVolatility","sharpeRatio","RISK_FREE_RATE","downsideReturns","downsideDeviation","sortinoRatio","calculateMaxDrawdownFromPrices","calmarRatio","informationRatio","treynorRatio","benchmarkMean","benchmarkVar","covariance","trackingError","analyzeRegime","bullCount","bearCount","totalCount","bullMarketProbability","bearMarketProbability","currentDuration","bullDurations","bearDurations","regimeDuration","bull","d","bear","bullReturns","_","bearReturns","regimeReturns","bullMean","bearMean","regimeVolatility","peak","drawdown","currentDrawdown","u","v","cos","PI","upside20Count","downside10Count","probabilities","upside20","downside10","sortedPrices","sort","a","b","minPrice","maxPrice","numBins","binSize","histogram","Array","fill","bin","count","forEach","binIndex","floor","percentiles","index","var95Index","var99Index","slice","testPipeline","errors","generateSyntheticWalk","allPrices","flat","every","performanceMetrics","isNaN","regimeAnalysis","error","message","success","numPoints","date","Date","u1","u2","return_","noise","open","high","low","volume"],"sources":["/Users/slongo/Documents/simone_misc/stock_widget/src/Analytics.ts"],"sourcesContent":["// src/Analytics.ts\nimport { PricePoint } from './DataFetch';\nimport { \n  AnalyticsParams, \n  AnalyticsResult, \n  StressTestScenario, \n  StressTestResult, \n  PerformanceMetrics, \n  RegimeAnalysis \n} from './types';\n\nexport class Analytics {\n  // Validation constants\n  private static readonly MIN_VARIANCE = 1e-8;\n  private static readonly MAX_VARIANCE = 1e4;\n  private static readonly MIN_PRICE = 0.01;\n  private static readonly RISK_FREE_RATE = 0.02; // 2% annual risk-free rate\n\n  static validateParams(params: AnalyticsParams): void {\n    if (params.alpha < 0 || params.alpha > 1) {\n      throw new Error('Alpha must be between 0 and 1');\n    }\n    if (params.beta < 0 || params.beta > 1) {\n      throw new Error('Beta must be between 0 and 1');\n    }\n    if (params.alpha + params.beta >= 1) {\n      throw new Error('Alpha + Beta must be less than 1 for GARCH stability');\n    }\n    if (params.theta < 0 || params.theta > 1) {\n      throw new Error('Theta must be between 0 and 1');\n    }\n    if (params.switchProb < 0 || params.switchProb > 1) {\n      throw new Error('Switch probability must be between 0 and 1');\n    }\n    if (params.numPaths < 100 || params.numPaths > 10000) {\n      throw new Error('Number of paths must be between 100 and 10000');\n    }\n    if (params.numSteps < 10 || params.numSteps > 1000) {\n      throw new Error('Number of steps must be between 10 and 1000');\n    }\n  }\n\n  static calculateReturns(prices: PricePoint[]): number[] {\n    if (prices.length < 2) {\n      throw new Error('Need at least 2 price points to calculate returns');\n    }\n\n    const returns: number[] = [];\n    for (let i = 1; i < prices.length; i++) {\n      if (prices[i - 1].close <= 0) {\n        throw new Error('Invalid price data: non-positive close price');\n      }\n      const ret = Math.log(prices[i].close / prices[i - 1].close);\n      returns.push(ret);\n    }\n    return returns;\n  }\n\n  static calculateGARCHVolatility(returns: number[], alpha: number, beta: number): number[] {\n    if (returns.length === 0) {\n      throw new Error('No returns data provided');\n    }\n\n    // Validate GARCH parameters\n    if (alpha < 0 || beta < 0 || alpha + beta >= 1) {\n      throw new Error('Invalid GARCH parameters: alpha + beta must be < 1');\n    }\n\n    const n = returns.length;\n    const volatilities: number[] = [];\n    \n    // Handle edge case with minimal data\n    if (n === 1) {\n      const volatility = Math.sqrt(Math.max(Math.pow(returns[0], 2), this.MIN_VARIANCE));\n      return [volatility];\n    }\n    \n    // Calculate sample variance for omega with robust estimation\n    const meanReturn = returns.reduce((sum, r) => sum + r, 0) / n;\n    const sampleVar = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (n - 1);\n    \n    // Ensure sample variance is positive and reasonable\n    const adjustedSampleVar = Math.max(sampleVar, this.MIN_VARIANCE);\n    const omega = adjustedSampleVar * (1 - alpha - beta);\n    \n    // Initialize first volatility\n    volatilities[0] = Math.sqrt(adjustedSampleVar);\n    \n    // GARCH(1,1) recursion: σ²_t = ω + α·r²_{t-1} + β·σ²_{t-1}\n    for (let t = 1; t < n; t++) {\n      const variance = omega + alpha * Math.pow(returns[t - 1], 2) + beta * Math.pow(volatilities[t - 1], 2);\n      \n      // Apply variance bounds for numerical stability\n      const boundedVariance = Math.max(Math.min(variance, this.MAX_VARIANCE), this.MIN_VARIANCE);\n      volatilities[t] = Math.sqrt(boundedVariance);\n    }\n    \n    return volatilities;\n  }\n\n  static calculateTrendAndDrift(prices: PricePoint[], theta: number): { trend: number; drift: number } {\n    if (prices.length < 2) {\n      throw new Error('Need at least 2 price points to calculate trend');\n    }\n\n    if (theta < 0 || theta > 1) {\n      throw new Error('Theta must be between 0 and 1');\n    }\n\n    const n = prices.length;\n    const logPrices = prices.map(p => {\n      if (p.close <= 0) {\n        throw new Error('Invalid price data: non-positive close price');\n      }\n      return Math.log(p.close);\n    });\n    \n    // OLS regression: y = mx + b\n    const xMean = (n - 1) / 2;\n    const yMean = logPrices.reduce((sum, y) => sum + y, 0) / n;\n    \n    let numerator = 0;\n    let denominator = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const x = i;\n      const y = logPrices[i];\n      numerator += (x - xMean) * (y - yMean);\n      denominator += Math.pow(x - xMean, 2);\n    }\n    \n    // Handle edge case where denominator is zero\n    if (Math.abs(denominator) < 1e-10) {\n      return { trend: prices[n - 1].close, drift: 0 };\n    }\n    \n    const slope = numerator / denominator;\n    const trend = Math.exp(slope * n); // Projected price based on trend\n    const currentPrice = prices[n - 1].close;\n    const drift = theta * (trend - currentPrice) / currentPrice;\n    \n    return { trend, drift };\n  }\n\n  static generateMarkovRegime(returns: number[], switchProb: number): number[] {\n    if (returns.length === 0) {\n      throw new Error('No returns data provided');\n    }\n\n    if (switchProb < 0 || switchProb > 1) {\n      throw new Error('Switch probability must be between 0 and 1');\n    }\n\n    const n = returns.length;\n    const regimes: number[] = [];\n    \n    // Start in regime based on last return\n    let currentRegime = returns[returns.length - 1] >= 0 ? 1 : -1;\n    \n    for (let t = 0; t < n; t++) {\n      regimes[t] = currentRegime;\n      \n      // Switch regime with probability switchProb\n      if (Math.random() < switchProb) {\n        currentRegime = -currentRegime;\n      }\n    }\n    \n    return regimes;\n  }\n\n  static runMonteCarloSimulation(\n    initialPrice: number,\n    params: AnalyticsParams,\n    initialVolatility: number,\n    drift: number\n  ): AnalyticsResult {\n    // Validate inputs\n    this.validateParams(params);\n    \n    if (initialPrice <= 0) {\n      throw new Error('Initial price must be positive');\n    }\n    \n    if (initialVolatility <= 0) {\n      throw new Error('Initial volatility must be positive');\n    }\n\n    const { numPaths, numSteps, alpha, beta } = params;\n    const paths: number[][] = [];\n    const dt = 1 / 252; // Daily time step\n    \n    // Calculate omega for GARCH\n    const omega = initialVolatility * initialVolatility * (1 - alpha - beta);\n    \n    for (let path = 0; path < numPaths; path++) {\n      const pathPrices: number[] = [initialPrice];\n      let currentPrice = initialPrice;\n      let currentVolatility = initialVolatility;\n      \n      for (let step = 0; step < numSteps; step++) {\n        // Generate random normal variable\n        const z = this.randomNormal();\n        \n        // Calculate return: ret = drift·dt - 0.5·σ²·dt + σ·√dt·Z\n        const ret = drift * dt - 0.5 * currentVolatility * currentVolatility * dt + \n                   currentVolatility * Math.sqrt(dt) * z;\n        \n        // Update price with bounds checking\n        currentPrice = currentPrice * Math.exp(ret);\n        if (currentPrice < this.MIN_PRICE) {\n          currentPrice = this.MIN_PRICE; // Prevent negative prices\n        }\n        pathPrices.push(currentPrice);\n        \n        // Update volatility using GARCH with bounds\n        const variance = omega + alpha * Math.pow(ret, 2) + beta * Math.pow(currentVolatility, 2);\n        const boundedVariance = Math.max(Math.min(variance, this.MAX_VARIANCE), this.MIN_VARIANCE);\n        currentVolatility = Math.sqrt(boundedVariance);\n      }\n      \n      paths.push(pathPrices);\n    }\n    \n    return this.calculateStatistics(paths, initialPrice);\n  }\n\n  // Advanced Analytics Methods\n\n  static runStressTest(\n    initialPrice: number,\n    params: AnalyticsParams,\n    initialVolatility: number,\n    drift: number,\n    scenarios: StressTestScenario[]\n  ): StressTestResult[] {\n    const results: StressTestResult[] = [];\n    \n    for (const scenario of scenarios) {\n      // Apply stress test parameters\n      const stressedParams = { ...params };\n      const stressedVolatility = initialVolatility * scenario.volatilityShock;\n      const stressedDrift = drift + scenario.driftShock;\n      \n      // Run simulation with stressed parameters\n      const result = this.runMonteCarloSimulation(\n        initialPrice,\n        stressedParams,\n        stressedVolatility,\n        stressedDrift\n      );\n      \n      // Calculate additional stress metrics\n      const finalPrices = result.paths.map(path => path[path.length - 1]);\n      const probabilityOfLoss = finalPrices.filter(price => price < initialPrice).length / finalPrices.length;\n      const maxDrawdown = this.calculateMaxDrawdown(result.paths, initialPrice);\n      \n      results.push({\n        scenario,\n        var95: result.var95,\n        var99: result.var99,\n        expectedShortfall95: result.expectedShortfall95,\n        expectedShortfall99: result.expectedShortfall99,\n        probabilityOfLoss,\n        maxDrawdown\n      });\n    }\n    \n    return results;\n  }\n\n  static calculatePerformanceMetrics(prices: PricePoint[], benchmarkReturns?: number[]): PerformanceMetrics {\n    const returns = this.calculateReturns(prices);\n    const meanReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;\n    const volatility = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / (returns.length - 1));\n    \n    // Annualize returns and volatility\n    const annualizedReturn = meanReturn * 252;\n    const annualizedVolatility = volatility * Math.sqrt(252);\n    \n    // Sharpe Ratio\n    const sharpeRatio = (annualizedReturn - this.RISK_FREE_RATE) / annualizedVolatility;\n    \n    // Sortino Ratio (using downside deviation)\n    const downsideReturns = returns.filter(r => r < meanReturn);\n    const downsideDeviation = Math.sqrt(downsideReturns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / downsideReturns.length);\n    const sortinoRatio = (annualizedReturn - this.RISK_FREE_RATE) / (downsideDeviation * Math.sqrt(252));\n    \n    // Maximum Drawdown\n    const maxDrawdown = this.calculateMaxDrawdownFromPrices(prices);\n    \n    // Calmar Ratio\n    const calmarRatio = annualizedReturn / Math.abs(maxDrawdown);\n    \n    // Beta and Alpha (if benchmark provided)\n    let beta = 1;\n    let alpha = 0;\n    let informationRatio = 0;\n    let treynorRatio = 0;\n    \n    if (benchmarkReturns && benchmarkReturns.length === returns.length) {\n      const benchmarkMean = benchmarkReturns.reduce((sum, r) => sum + r, 0) / benchmarkReturns.length;\n      const benchmarkVar = benchmarkReturns.reduce((sum, r) => sum + Math.pow(r - benchmarkMean, 2), 0) / (benchmarkReturns.length - 1);\n      \n      // Calculate covariance\n      let covariance = 0;\n      for (let i = 0; i < returns.length; i++) {\n        covariance += (returns[i] - meanReturn) * (benchmarkReturns[i] - benchmarkMean);\n      }\n      covariance /= (returns.length - 1);\n      \n      beta = covariance / benchmarkVar;\n      alpha = annualizedReturn - (this.RISK_FREE_RATE + beta * (benchmarkMean * 252 - this.RISK_FREE_RATE));\n      \n      // Information Ratio\n      const trackingError = Math.sqrt(returns.reduce((sum, r, i) => sum + Math.pow(r - benchmarkReturns[i], 2), 0) / returns.length);\n      informationRatio = (annualizedReturn - benchmarkMean * 252) / (trackingError * Math.sqrt(252));\n      \n      // Treynor Ratio\n      treynorRatio = (annualizedReturn - this.RISK_FREE_RATE) / beta;\n    }\n    \n    return {\n      sharpeRatio,\n      sortinoRatio,\n      maxDrawdown,\n      calmarRatio,\n      informationRatio,\n      beta,\n      alpha,\n      treynorRatio\n    };\n  }\n\n  static analyzeRegime(returns: number[], regimes: number[]): RegimeAnalysis {\n    if (returns.length !== regimes.length) {\n      throw new Error('Returns and regimes arrays must have the same length');\n    }\n    \n    // Calculate regime probabilities\n    const bullCount = regimes.filter(r => r > 0).length;\n    const bearCount = regimes.filter(r => r < 0).length;\n    const totalCount = regimes.length;\n    \n    const bullMarketProbability = bullCount / totalCount;\n    const bearMarketProbability = bearCount / totalCount;\n    \n    // Calculate regime durations\n    let currentRegime = regimes[0];\n    let currentDuration = 1;\n    const bullDurations: number[] = [];\n    const bearDurations: number[] = [];\n    \n    for (let i = 1; i < regimes.length; i++) {\n      if (regimes[i] === currentRegime) {\n        currentDuration++;\n      } else {\n        if (currentRegime > 0) {\n          bullDurations.push(currentDuration);\n        } else {\n          bearDurations.push(currentDuration);\n        }\n        currentRegime = regimes[i];\n        currentDuration = 1;\n      }\n    }\n    \n    // Add final regime\n    if (currentRegime > 0) {\n      bullDurations.push(currentDuration);\n    } else {\n      bearDurations.push(currentDuration);\n    }\n    \n    // Calculate regime statistics\n    const regimeDuration = {\n      bull: bullDurations.length > 0 ? bullDurations.reduce((sum, d) => sum + d, 0) / bullDurations.length : 0,\n      bear: bearDurations.length > 0 ? bearDurations.reduce((sum, d) => sum + d, 0) / bearDurations.length : 0\n    };\n    \n    // Calculate regime-specific returns and volatility\n    const bullReturns = returns.filter((_, i) => regimes[i] > 0);\n    const bearReturns = returns.filter((_, i) => regimes[i] < 0);\n    \n    const regimeReturns = {\n      bull: bullReturns.length > 0 ? bullReturns.reduce((sum, r) => sum + r, 0) / bullReturns.length : 0,\n      bear: bearReturns.length > 0 ? bearReturns.reduce((sum, r) => sum + r, 0) / bearReturns.length : 0\n    };\n    \n    const bullMean = bullReturns.length > 0 ? bullReturns.reduce((sum, r) => sum + r, 0) / bullReturns.length : 0;\n    const bearMean = bearReturns.length > 0 ? bearReturns.reduce((sum, r) => sum + r, 0) / bearReturns.length : 0;\n    \n    const regimeVolatility = {\n      bull: bullReturns.length > 0 ? Math.sqrt(bullReturns.reduce((sum, r) => sum + Math.pow(r - bullMean, 2), 0) / (bullReturns.length - 1)) : 0,\n      bear: bearReturns.length > 0 ? Math.sqrt(bearReturns.reduce((sum, r) => sum + Math.pow(r - bearMean, 2), 0) / (bearReturns.length - 1)) : 0\n    };\n    \n    return {\n      bullMarketProbability,\n      bearMarketProbability,\n      regimeDuration,\n      regimeVolatility,\n      regimeReturns\n    };\n  }\n\n  // Helper methods\n\n  private static calculateMaxDrawdown(paths: number[][], initialPrice: number): number {\n    let maxDrawdown = 0;\n    \n    for (const path of paths) {\n      let peak = initialPrice;\n      let drawdown = 0;\n      \n      for (const price of path) {\n        if (price > peak) {\n          peak = price;\n        }\n        const currentDrawdown = (peak - price) / peak;\n        if (currentDrawdown > drawdown) {\n          drawdown = currentDrawdown;\n        }\n      }\n      \n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n    \n    return maxDrawdown;\n  }\n\n  private static calculateMaxDrawdownFromPrices(prices: PricePoint[]): number {\n    let peak = prices[0].close;\n    let maxDrawdown = 0;\n    \n    for (const price of prices) {\n      if (price.close > peak) {\n        peak = price.close;\n      }\n      const drawdown = (peak - price.close) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n    \n    return maxDrawdown;\n  }\n\n  private static randomNormal(): number {\n    // Box-Muller transform for normal random variables\n    const u = Math.random();\n    const v = Math.random();\n    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);\n  }\n\n  private static calculateStatistics(paths: number[][], initialPrice: number): AnalyticsResult {\n    const numPaths = paths.length;\n    const finalPrices = paths.map(path => path[path.length - 1]);\n    \n    // Calculate probabilities\n    const upside20Count = finalPrices.filter(price => price >= initialPrice * 1.2).length;\n    const downside10Count = finalPrices.filter(price => price <= initialPrice * 0.9).length;\n    \n    const probabilities = {\n      upside20: upside20Count / numPaths,\n      downside10: downside10Count / numPaths\n    };\n    \n    // Calculate histogram\n    const sortedPrices = [...finalPrices].sort((a, b) => a - b);\n    const minPrice = sortedPrices[0];\n    const maxPrice = sortedPrices[sortedPrices.length - 1];\n    const numBins = 50;\n    const binSize = (maxPrice - minPrice) / numBins;\n    \n    const histogram = Array(numBins).fill(0).map((_, i) => ({\n      bin: minPrice + i * binSize,\n      count: 0\n    }));\n    \n    finalPrices.forEach(price => {\n      const binIndex = Math.min(Math.floor((price - minPrice) / binSize), numBins - 1);\n      histogram[binIndex].count++;\n    });\n    \n    // Calculate percentiles\n    const percentiles: { [key: string]: number } = {};\n    [5, 10, 25, 50, 75, 90, 95].forEach(p => {\n      const index = Math.floor((p / 100) * (numPaths - 1));\n      percentiles[`p${p}`] = sortedPrices[index];\n    });\n    \n    // Calculate VaR and Expected Shortfall\n    const var95Index = Math.floor(0.05 * numPaths);\n    const var99Index = Math.floor(0.01 * numPaths);\n    const var95 = initialPrice - sortedPrices[var95Index];\n    const var99 = initialPrice - sortedPrices[var99Index];\n    \n    const expectedShortfall95 = (initialPrice - \n      sortedPrices.slice(0, var95Index + 1).reduce((sum, price) => sum + price, 0) / (var95Index + 1));\n    const expectedShortfall99 = (initialPrice - \n      sortedPrices.slice(0, var99Index + 1).reduce((sum, price) => sum + price, 0) / (var99Index + 1));\n    \n    return {\n      paths,\n      probabilities,\n      histogram,\n      percentiles,\n      var95,\n      var99,\n      expectedShortfall95,\n      expectedShortfall99,\n      currentVolatility: 0, // Will be set by caller\n      trend: 0, // Will be set by caller\n      drift: 0 // Will be set by caller\n    };\n  }\n\n  // Comprehensive test pipeline for validation\n  static testPipeline(): { success: boolean; errors: string[] } {\n    const errors: string[] = [];\n    \n    try {\n      // Generate synthetic data\n      const prices = this.generateSyntheticWalk(100, 0.001, 0.01);\n      \n      // Test all components\n      const returns = this.calculateReturns(prices);\n      const volatilities = this.calculateGARCHVolatility(returns, 0.1, 0.8);\n      const { drift } = this.calculateTrendAndDrift(prices, 0.05);\n      const regimes = this.generateMarkovRegime(returns, 0.05);\n      \n      const params: AnalyticsParams = {\n        alpha: 0.1,\n        beta: 0.8,\n        theta: 0.05,\n        switchProb: 0.05,\n        numPaths: 10,\n        numSteps: 10\n      };\n      \n      const result = this.runMonteCarloSimulation(\n        prices[prices.length - 1].close,\n        params,\n        volatilities[volatilities.length - 1],\n        drift\n      );\n      \n      // Validation checks\n      if (result.paths.length !== 10 || result.paths[0].length !== 11) {\n        errors.push('Invalid path dimensions');\n      }\n      \n      if (result.probabilities.upside20 < 0 || result.probabilities.upside20 > 1) {\n        errors.push('Invalid upside probability');\n      }\n      \n      if (result.probabilities.downside10 < 0 || result.probabilities.downside10 > 1) {\n        errors.push('Invalid downside probability');\n      }\n      \n      if (result.var95 < 0 || result.var99 < 0) {\n        errors.push('Invalid VaR values');\n      }\n      \n      // Check for positive prices\n      const allPrices = result.paths.flat();\n      if (!allPrices.every(price => price > 0)) {\n        errors.push('Non-positive prices detected');\n      }\n      \n      // Test advanced features\n      const performanceMetrics = this.calculatePerformanceMetrics(prices);\n      if (isNaN(performanceMetrics.sharpeRatio)) {\n        errors.push('Invalid Sharpe ratio');\n      }\n      \n      const regimeAnalysis = this.analyzeRegime(returns, regimes);\n      if (regimeAnalysis.bullMarketProbability + regimeAnalysis.bearMarketProbability !== 1) {\n        errors.push('Invalid regime probabilities');\n      }\n      \n    } catch (error) {\n      errors.push(error instanceof Error ? error.message : 'Unknown error in test pipeline');\n    }\n    \n    return {\n      success: errors.length === 0,\n      errors\n    };\n  }\n\n  private static generateSyntheticWalk(numPoints: number, meanReturn: number, volatility: number): PricePoint[] {\n    const prices: PricePoint[] = [];\n    let currentPrice = 100; // Start at $100\n    \n    for (let i = 0; i < numPoints; i++) {\n      const date = new Date(2024, 0, i + 1); // Start from Jan 1, 2024\n      \n      if (i > 0) {\n        // Generate random return using Box-Muller transform\n        const u1 = Math.random();\n        const u2 = Math.random();\n        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        const return_ = meanReturn + volatility * z;\n        currentPrice = currentPrice * Math.exp(return_);\n      }\n      \n      const noise = 0.001; // Small noise for OHLC\n      prices.push({\n        date,\n        open: currentPrice * (1 + (Math.random() - 0.5) * noise),\n        high: currentPrice * (1 + Math.abs(Math.random()) * noise),\n        low: currentPrice * (1 - Math.abs(Math.random()) * noise),\n        close: currentPrice,\n        volume: Math.floor(Math.random() * 1000000)\n      });\n    }\n    \n    return prices;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}